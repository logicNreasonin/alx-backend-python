// Declarative Pipeline for the Django Messaging App

pipeline {
    // 1. Specify the agent
    // 'agent any' means Jenkins can use any available agent (executor) to run this pipeline.
    agent any

    // 2. Define environment variables (optional but good practice)
    environment {
        // Define a variable for the virtual environment directory name
        VENV_DIR = '.venv'
    }

    // 3. Define the stages of the pipeline
    stages {
        // STAGE 1: Checkout code from Source Control (GitHub)
        stage('Checkout from GitHub') {
            steps {
                // Clean the workspace before checking out new code to prevent conflicts
                cleanWs()
                echo 'Checking out code...'
                // The 'git' step uses the Git plugin.
                // It requires credentials to be configured in Jenkins with the ID 'github-credentials'.
                // Replace 'your-github-username' with your actual GitHub username.
                git credentialsId: 'github-credentials', url: 'https://github.com/logicNreasonin/alx-backend-python.git', branch: 'main'
            }
        }

        // STAGE 2: Set up Python environment and install project dependencies
        stage('Setup Environment & Install Dependencies') {
            steps {
                // Use the ShiningPanda plugin wrapper.
                // It creates a virtual environment and runs commands within it.
                // Assumes 'python3' is available on the Jenkins agent.
                withPythonEnv('python3') {
                    script {
                        echo "Python virtual environment activated."
                        echo "Installing dependencies from requirements.txt..."
                        // Run a shell command to install dependencies into the virtual environment.
                        // This assumes your requirements.txt is at the root of the 'messaging_app' directory.
                        // Adjust the path if it's located elsewhere (e.g., '../requirements.txt' if at repo root).
                        sh 'pip install -r requirements.txt'
                    }
                }
            }
        }

        // STAGE 3: Run tests using pytest
        stage('Run Tests') {
            steps {
                // Reuse the same virtual environment setup
                withPythonEnv('python3') {
                    script {
                        echo "Running tests with Pytest..."
                        // Run pytest and generate a JUnit XML formatted report.
                        // This is a standard format that Jenkins can easily parse.
                        // Create the 'reports' directory first to prevent errors.
                        sh 'mkdir -p reports'
                        // If any tests fail, pytest will exit with a non-zero status code,
                        // which will automatically fail this stage and stop the pipeline.
                        // Note: Replace 'your_django_project.tests' with the path to your test files if pytest can't auto-discover them.
                        // Usually running pytest from the directory containing it is enough.
                        // Assuming the tests for the app are in 'messaging_app', you can target it.
                        sh 'pytest messaging_app/ --junitxml=reports/junit-report.xml'
                    }
                }
            }
        }
    }

    // 4. Define post-build actions
    // This 'post' block runs after all stages have completed.
    post {
        // 'always' means this will run regardless of whether the pipeline succeeded, failed, or was aborted.
        always {
            echo "Archiving test reports..."
            // Use the JUnit plugin to collect and display the test results.
            // This provides a "Test Result" link on the build page with graphs and details.
            junit 'reports/junit-report.xml'

            echo "Cleaning up workspace..."
            // Clean the workspace after the build to save disk space on the Jenkins server.
            cleanWs()
        }
        // You could add other blocks like 'success', 'failure', etc., for notifications.
        // success {
        //     echo 'Pipeline completed successfully!'
        // }
        // failure {
        //     echo 'Pipeline failed. Please check the logs.'
        // }
    }
}