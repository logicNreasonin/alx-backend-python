// messaging_app/Jenkinsfile

pipeline {
    // 1. Agent Configuration
    // The 'agent' specifies where the Pipeline will execute. 'any' means Jenkins can use any available agent.
    agent any

    // 2. Environment Variables
    // The 'environment' block configures variables available for all steps in the pipeline.
    environment {
        // Sets the Python buffer to unbuffered to see real-time output from tests in the Jenkins logs.
        PYTHONUNBUFFERED = '1'
        // Specifies the virtual environment directory name for consistency and cleanup.
        VENV_DIR = 'venv'
    }

    // 3. Stages
    // The 'stages' section defines a sequence of 'stage' blocks, which are the main parts of your pipeline.
    stages {

        // --- Stage 1: Checkout ---
        // This stage clones the source code from your GitHub repository.
        stage('Checkout Source Code') {
            steps {
                echo 'Checking out code from GitHub...'
                // The 'checkout scm' step uses the SCM configuration from the Jenkins job setup,
                // including the repository URL and credentials.
                checkout scm
                echo 'Checkout complete.'
            }
        }

        // --- Stage 2: Install Dependencies ---
        // This stage creates a Python virtual environment and installs project dependencies.
        stage('Install Dependencies') {
            steps {
                script {
                    echo "Creating Python virtual environment named '${VENV_DIR}'..."
                    // Use 'python3' if 'python' is not aliased correctly on the agent.
                    // This creates a self-contained environment to avoid dependency conflicts.
                    sh "python3 -m venv ${VENV_DIR}"

                    echo 'Activating virtual environment and installing project dependencies...'
                    // Each 'sh' step runs in its own shell, so you must activate the venv and run
                    // commands in the same step.
                    // This assumes a 'requirements.txt' file exists in your repo's root directory.
                    if (fileExists('requirements.txt')) {
                        sh ". ${VENV_DIR}/bin/activate && pip install --upgrade pip && pip install -r requirements.txt"
                        echo 'Dependencies installed from requirements.txt.'
                    } else {
                        // If no requirements.txt, just install pytest for the tests to run.
                        echo 'requirements.txt not found. Installing pytest directly...'
                        sh ". ${VENV_DIR}/bin/activate && pip install --upgrade pip && pip install pytest"
                    }
                }
            }
        }

        // --- Stage 3: Run Tests with Pytest ---
        // This stage executes the tests and generates a standard report for Jenkins.
        stage('Run Tests') {
            steps {
                script {
                    echo 'Running tests using pytest...'
                    // We use a try-catch-finally block to ensure that the test report is published
                    // even if the tests fail, which is a crucial part of CI.
                    try {
                        // Run pytest from within the virtual environment.
                        // '--junitxml' generates a report in a format Jenkins understands (JUnit XML).
                        // It's good practice to place reports in a dedicated directory.
                        sh "mkdir -p reports"
                        sh ". ${VENV_DIR}/bin/activate && pytest --junitxml=reports/report.xml"
                    } catch (Exception err) {
                        echo "Tests failed. The build will be marked as unstable or failed."
                        // Re-throw the error to ensure the pipeline's overall status reflects the failure.
                        throw err
                    } finally {
                        // The 'finally' block ensures this step always runs after the 'try' block.
                        echo 'Publishing test report...'
                        // The 'junit' step, provided by the JUnit Plugin, parses the XML report
                        // and displays the results beautifully on the Jenkins job page,
                        // including trends and specific failures.
                        // 'allowEmptyResults: true' prevents an error if no tests were found.
                        junit allowEmptyResults: true, testResults: 'reports/**/*.xml'
                    }
                }
            }
        }
    }

    // 4. Post-build Actions
    // The 'post' section defines actions that run at the end of the pipeline's execution.
    post {
        // The 'always' block runs regardless of the pipeline's outcome (success, failure, etc.).
        // It's the perfect place for cleanup tasks.
        always {
            echo 'Pipeline finished. Cleaning up workspace...'
            // Remove the virtual environment to ensure the workspace is clean for the next build.
            sh "rm -rf ${VENV_DIR} reports"
        }
    }
}