// messaging_app/Jenkinsfile

pipeline {
    // 1. Agent Configuration (THE KEY CHANGE IS HERE)
    // We now specify a Docker agent. Jenkins will pull this official Python image
    // and run all the stages inside a container created from it.
    agent {
        docker {
            image 'python:3.9-slim' // A lightweight, official Python image
            args '-u root' // Run as root user inside the container to avoid permission issues when creating files
        }
    }

    // 2. Environment Variables (No change here)
    environment {
        PYTHONUNBUFFERED = '1'
        VENV_DIR = 'venv'
    }

    // 3. Stages (The logic inside remains the same)
    stages {

        // --- Stage 1: Checkout ---
        // Checkout stage no longer needed as Jenkins handles it automatically
        // when using a Docker agent. The source code is mounted into the container.

        // --- Stage 2: Install Dependencies ---
        stage('Install Dependencies') {
            steps {
                script {
                    echo "Python version check inside the container:"
                    sh "python --version"

                    echo "Creating Python virtual environment named '${VENV_DIR}'..."
                    sh "python -m venv ${VENV_DIR}"

                    echo 'Activating virtual environment and installing project dependencies...'
                    // This logic is now cleaner and more robust
                    if (fileExists('requirements.txt')) {
                        // Activate the venv, upgrade pip, and install from requirements.txt
                        sh ". ${VENV_DIR}/bin/activate && pip install --upgrade pip && pip install -r requirements.txt"

                        // If your project code needs to be importable (e.g., you have a setup.py),
                        // install it in editable mode. If not, this step can be skipped.
                        // Assuming messaging_app might have local modules to test:
                        // sh ". ${VENV_DIR}/bin/activate && pip install -e ."

                        echo 'Dependencies installed from requirements.txt.'
                    } else {
                        // This 'else' block can now be removed or kept as a fallback.
                        // It's better to make requirements.txt a hard requirement for the build.
                        error "A 'requirements.txt' file was not found in the root of the repository. This is required to run the pipeline."
                    }
                }
            }
        }

        // --- Stage 3: Run Tests with Pytest ---
        stage('Run Tests') {
            steps {
                script {
                    echo 'Running tests using pytest...'
                    try {
                        sh "mkdir -p reports"
                        // Note the command is now 'python -m pytest' which is a reliable way to call pytest from the venv
                        sh ". ${VENV_DIR}/bin/activate && python -m pytest --junitxml=reports/report.xml"
                    } catch (Exception err) {
                        echo "Tests failed. The build will be marked as unstable or failed."
                        throw err
                    } finally {
                        echo 'Publishing test report...'
                        junit allowEmptyResults: true, testResults: 'reports/**/*.xml'
                    }
                }
            }
        }
    }

    // 4. Post-build Actions (No change here)
    post {
        always {
            echo 'Pipeline finished. Cleaning up workspace...'
            // Clean up the directories created inside the container
            sh "rm -rf ${VENV_DIR} reports"
        }
    }
}